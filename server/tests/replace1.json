{
    "name": "replace1",
    "requests": [
        {
            "url": "/edit/create",
            "params": {
                "path": "/server/src/analyze.ts",
                "operations": [
                    {
                        "op": "replace",
                        "params": {
                            "anchorText": "if (type === FileType.Directory && depth > 1) {",
                            "newCode": "if (type === FileType.Directory) {\n            const directoryEntry: DirectoryEntry = {\n                name,\n                type: 'directory',\n                children: [],\n            };\n\n            if (depth > 1) {"
                        }
                    },
                    {
                        "op": "replace",
                        "params": {
                            "anchorText": "const subDirectoryResult = await analyzeDirectory(subDirectoryOptions);\n            result.children.push(subDirectoryResult);",
                            "newCode": "const subDirectoryResult = await analyzeDirectory(subDirectoryOptions);\n                directoryEntry.children = subDirectoryResult.children;\n            }\n\n            result.children.push(directoryEntry);"
                        }
                    }
                ],
                "allowStaleEdits": true
            },
            "statusCode": 201
        },
        {
            "url": "/edit/apply",
            "params": {
                "path": "/server/src/analyze.ts",
                "draftID": "1"
            },
            "statusCode": 200
        }
    ],
    "fsBefore": {
        "server/src/analyze.ts": "import type { Uri } from 'vscode';\nimport { FileType, ReadableFileSystem } from './filesystem';\nimport { SafeError } from './handlers/errors';\n\nexport interface AnalyzeFileOptions {\n    fs: ReadableFileSystem;\n    path: string;\n    characterLimit?: number;\n    startLine?: number;\n    endLine?: number;\n}\n\nexport interface AnalyzeFileResult {\n    data: string;\n    nextOptions?: Partial<AnalyzeFileOptions>; // contains new startLine and endLine if the file was truncated\n}\n\nexport interface AnalyzeDirectoryOptions {\n    fs: ReadableFileSystem;\n    path: string;\n    depth?: number; // defaults to 1 (i.e. read only the top-level directory)\n    ignore?: string[]; // globs relative to `path`\n    filter?: string; // JS arrow function that will be evaluated. directory path and file name are passed as arguments, return true to include the file\n}\n\ninterface DirectoryEntry {\n    size?: number;\n    name: string;\n    type: 'file' | 'directory';\n    children: DirectoryEntry[];\n}\n\nexport interface AnalyzeDirectoryResult extends DirectoryEntry {}\n\nexport async function analyzeFile(options: AnalyzeFileOptions): Promise<AnalyzeFileResult> {\n    const { fs, path, characterLimit = Infinity } = options;\n    const uri = { scheme: 'file', path } as Uri;\n    const fileStat = await fs.stat(uri);\n\n    // Account for the fact that lines are 1-indexed and ranges are inclusive\n    let { startLine = 1, endLine } = options;\n    startLine--;\n\n    if (fileStat.type !== FileType.File) {\n        throw new SafeError(`Not a file: ${path}`);\n    }\n\n    const fileContent = new TextDecoder().decode(await fs.readFile(uri));\n\n    const allLines = fileContent.split('\n');\n    const lines = allLines.slice(startLine, endLine);\n\n    // Add line numbers\n    for (let i = startLine; i < (endLine || lines.length); i++) {\n        lines[i] = (startLine + i + 1).toString() + ': ' + lines[i];\n    }\n\n    if (lines.join('\n').length > characterLimit) {\n        const truncatedLines = [];\n        let characterCount = 0;\n\n        for (const line of lines) {\n            // account for the newline character's length\n            if (characterCount + line.length + 1 > characterLimit) {\n                break;\n            }\n            truncatedLines.push(line);\n            characterCount += line.length + 1; // +1 for the newline character\n        }\n\n        const nextStartLine = startLine + truncatedLines.length;\n        let nextEndLine;\n        if (endLine !== undefined) {\n            nextEndLine = nextStartLine + (endLine - startLine);\n        }\n\n        return {\n            data: truncatedLines.join('\n'),\n            nextOptions:\n                nextEndLine !== undefined\n                    ? { startLine: nextStartLine, endLine: nextEndLine }\n                    : { startLine: nextStartLine },\n        };\n    }\n\n    let nextOptions =\n        endLine === undefined\n            ? undefined\n            : {\n                  startLine: endLine + 1,\n                  endLine: endLine + (endLine - startLine),\n              };\n\n    if (nextOptions && nextOptions.startLine >= allLines.length) {\n        nextOptions = undefined;\n    }\n\n    return {\n        data: lines.join('\n'),\n        nextOptions,\n    };\n}\n\nexport async function analyzeDirectory(options: AnalyzeDirectoryOptions): Promise<AnalyzeDirectoryResult> {\n    const { fs, path, depth = 1, ignore = [], filter } = options;\n    const uri = { scheme: 'file', path } as Uri;\n    const fileStat = await fs.stat(uri);\n\n    if (fileStat.type !== FileType.Directory) {\n        throw new Error(`Not a directory: ${path}`);\n    }\n\n    const directoryEntries = await fs.readDirectory(uri);\n    const result: AnalyzeDirectoryResult = {\n        name: path.split('/').pop()!,\n        type: 'directory',\n        children: [],\n    };\n\n    const isIgnored = (name: string) => ignore.includes(name);\n    const passesFilter = (name: string) => !filter || eval(filter)(path, name);\n\n    for (const [name, type] of directoryEntries) {\n        if (isIgnored(name) || !passesFilter(name)) {\n            continue;\n        }\n\n        if (type === FileType.File) {\n            const fileUri = { scheme: 'file', path: `${path}/${name}` } as Uri;\n            const fileStat = await fs.stat(fileUri);\n            const fileSize = fileStat.size;\n            result.children.push({\n                name,\n                type: 'file',\n                size: fileSize,\n                children: [],\n            });\n        } else if (type === FileType.Directory && depth > 1) {\n            const subDirectoryOptions: AnalyzeDirectoryOptions = {\n                fs,\n                path: `${path}/${name}`,\n                depth: depth - 1,\n                ignore,\n                filter,\n            };\n            const subDirectoryResult = await analyzeDirectory(subDirectoryOptions);\n            result.children.push(subDirectoryResult);\n        }\n    }\n\n    return result;\n}\n"
    },
    "fsAfter": {
        "server/src/analyze.ts": "import type { Uri } from 'vscode';\nimport { FileType, ReadableFileSystem } from './filesystem';\nimport { SafeError } from './handlers/errors';\n\nexport interface AnalyzeFileOptions {\n    fs: ReadableFileSystem;\n    path: string;\n    characterLimit?: number;\n    startLine?: number;\n    endLine?: number;\n}\n\nexport interface AnalyzeFileResult {\n    data: string;\n    nextOptions?: Partial<AnalyzeFileOptions>; // contains new startLine and endLine if the file was truncated\n}\n\nexport interface AnalyzeDirectoryOptions {\n    fs: ReadableFileSystem;\n    path: string;\n    depth?: number; // defaults to 1 (i.e. read only the top-level directory)\n    ignore?: string[]; // globs relative to `path`\n    filter?: string; // JS arrow function that will be evaluated. directory path and file name are passed as arguments, return true to include the file\n}\n\ninterface DirectoryEntry {\n    size?: number;\n    name: string;\n    type: 'file' | 'directory';\n    children: DirectoryEntry[];\n}\n\nexport interface AnalyzeDirectoryResult extends DirectoryEntry {}\n\nexport async function analyzeFile(options: AnalyzeFileOptions): Promise<AnalyzeFileResult> {\n    const { fs, path, characterLimit = Infinity } = options;\n    const uri = { scheme: 'file', path } as Uri;\n    const fileStat = await fs.stat(uri);\n\n    // Account for the fact that lines are 1-indexed and ranges are inclusive\n    let { startLine = 1, endLine } = options;\n    startLine--;\n\n    if (fileStat.type !== FileType.File) {\n        throw new SafeError(`Not a file: ${path}`);\n    }\n\n    const fileContent = new TextDecoder().decode(await fs.readFile(uri));\n\n    const allLines = fileContent.split('\n');\n    const lines = allLines.slice(startLine, endLine);\n\n    // Add line numbers\n    for (let i = startLine; i < (endLine || lines.length); i++) {\n        lines[i] = (startLine + i + 1).toString() + ': ' + lines[i];\n    }\n\n    if (lines.join('\n').length > characterLimit) {\n        const truncatedLines = [];\n        let characterCount = 0;\n\n        for (const line of lines) {\n            // account for the newline character's length\n            if (characterCount + line.length + 1 > characterLimit) {\n                break;\n            }\n            truncatedLines.push(line);\n            characterCount += line.length + 1; // +1 for the newline character\n        }\n\n        const nextStartLine = startLine + truncatedLines.length;\n        let nextEndLine;\n        if (endLine !== undefined) {\n            nextEndLine = nextStartLine + (endLine - startLine);\n        }\n\n        return {\n            data: truncatedLines.join('\n'),\n            nextOptions:\n                nextEndLine !== undefined\n                    ? { startLine: nextStartLine, endLine: nextEndLine }\n                    : { startLine: nextStartLine },\n        };\n    }\n\n    let nextOptions =\n        endLine === undefined\n            ? undefined\n            : {\n                  startLine: endLine + 1,\n                  endLine: endLine + (endLine - startLine),\n              };\n\n    if (nextOptions && nextOptions.startLine >= allLines.length) {\n        nextOptions = undefined;\n    }\n\n    return {\n        data: lines.join('\n'),\n        nextOptions,\n    };\n}\n\nexport async function analyzeDirectory(options: AnalyzeDirectoryOptions): Promise<AnalyzeDirectoryResult> {\n    const { fs, path, depth = 1, ignore = [], filter } = options;\n    const uri = { scheme: 'file', path } as Uri;\n    const fileStat = await fs.stat(uri);\n\n    if (fileStat.type !== FileType.Directory) {\n        throw new Error(`Not a directory: ${path}`);\n    }\n\n    const directoryEntries = await fs.readDirectory(uri);\n    const result: AnalyzeDirectoryResult = {\n        name: path.split('/').pop()!,\n        type: 'directory',\n        children: [],\n    };\n\n    const isIgnored = (name: string) => ignore.includes(name);\n    const passesFilter = (name: string) => !filter || eval(filter)(path, name);\n\n    for (const [name, type] of directoryEntries) {\n        if (isIgnored(name) || !passesFilter(name)) {\n            continue;\n        }\n\n        if (type === FileType.File) {\n            const fileUri = { scheme: 'file', path: `${path}/${name}` } as Uri;\n            const fileStat = await fs.stat(fileUri);\n            const fileSize = fileStat.size;\n            result.children.push({\n                name,\n                type: 'file',\n                size: fileSize,\n                children: [],\n            });\n        } else if (type === FileType.Directory) {\n            const directoryEntry: DirectoryEntry = {\n                name,\n                type: 'directory',\n                children: [],\n            };\n\n            if (depth > 1) {\n            const subDirectoryOptions: AnalyzeDirectoryOptions = {\n                fs,\n                path: `${path}/${name}`,\n                depth: depth - 1,\n                ignore,\n                filter,\n            };\n            const subDirectoryResult = await analyzeDirectory(subDirectoryOptions);\n                directoryEntry.children = subDirectoryResult.children;\n            }\n\n            result.children.push(directoryEntry);\n        }\n    }\n\n    return result;\n}\n"
    }
}
